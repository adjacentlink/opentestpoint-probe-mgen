#
# Copyright (c) 2022 - Adjacent Link LLC, Bridgewater, New Jersey
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in
#    the documentation and/or other materials provided with the
#    distribution.
#  * Neither the name of Adjacent Link LLC nor the names of its
#    contributors may be used to endorse or promote products derived
#    from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#
# See toplevel COPYING for more information.
#

"""
IP Route probe
"""
from otestpoint.interface import Probe
from otestpoint.interface.measurementtable_pb2 import MeasurementTable
import otestpoint.toolkit.logger as Logger
from .mgen_pb2 import Measurement_mgen_flows_receive
from .mgen_pb2 import Measurement_mgen_flows_transmit

import os
import time
import re
import functools
from lxml import etree
from threading import Thread
from threading import Event
from threading import Lock
from dataclasses import dataclass
from collections import deque

@dataclass
class ReceiveFlow:
    source: str
    flow: int
    destination: str
    packets: int = 0
    bytes_accum: int = 0
    latency_accum = 0
    dup_packets: int = 0
    dup_bytes_accum: int = 0

@dataclass
class TransmitFlow:
    source_port: int
    flow: int
    destination: str
    packets: int = 0
    bytes_accum: int = 0

class Flows(Probe):
    schema="""\
<xs:schema xmlns:xs='http://www.w3.org/2001/XMLSchema'>
  <xs:element name='otestpoint-probe-mgen'>
    <xs:complexType>
      <xs:attribute name='mgen-output-file' type='xs:string' use='required'/>
    </xs:complexType>
  </xs:element>
</xs:schema>"""

    def initialize(self,configurationFile=None):
        """
        Initialize the probe.

        Returns:
        The probe name list.
        """
        self._logger.log(Logger.DEBUG_LEVEL,
                         "/mgen/flows initialize"
                         " configuration: %s" % configurationFile)

        tree = etree.parse(configurationFile)

        root = tree.getroot()

        schemaDoc = etree.fromstring(Flows.schema)
        
        schema = etree.XMLSchema(etree=schemaDoc,attribute_defaults=True)

        if not schema(root):
            message = ""
            for entry in schema.error_log:
                message += "%d: %s " % (entry.line,entry.message)
            self._logger.log(Logger.ERROR_LEVEL,"/%s %s" % (self._name,message))
            raise ProbeException(message)

        self._mgen_output_file = root.get('mgen-output-file')

        self._logger.log(Logger.DEBUG_LEVEL,
                         "/mgen/flows mgen outout file: %s " %
                         self._mgen_output_file)
        
        receive_labels = ['Src',
                          'Dst',
                          'Flow',
                          'Pkts',
                          'Bytes',
                          'Dup Pkts',
                          'Dup Bytes',
                          'Avg Latency']

        transmit_labels = ['Src Port',
                           'Dst',
                           'Flow',
                           'Pkts',
                           'Bytes']

        self._measurement_rx = Measurement_mgen_flows_receive()

        self._measurement_rx.flows_udp.labels.extend(receive_labels)

        self._measurement_rx.flows_tcp.labels.extend(receive_labels)

        self._measurement_tx = Measurement_mgen_flows_transmit()

        self._measurement_tx.flows_udp.labels.extend(transmit_labels)

        self._measurement_tx.flows_tcp.labels.extend(transmit_labels)

        self._shutdown_event = Event()
        self._lock = Lock()
        self._rx_udp = {}
        self._tx_udp = {}
        self._rx_tcp = {}
        self._tx_tcp = {}
        self._seq_history = deque([],3)
        
        return ('MGEN.Flows.Receive',
                'MGEN.Flows.Transmit')

    def start(self):
        """
        Starts the probe.

        This method does nothing.
        """
        self._logger.log(Logger.DEBUG_LEVEL,'/mgen/flows start')

        self._thread = Thread(target=functools.partial(Flows.process,self))

        self._thread.start()

        
    def stop(self):
        """
        Stops the probe.

        This method does nothing.
        """
        self._logger.log(Logger.DEBUG_LEVEL,'/mgen/flows stop')
        self._shutdown_event.set()
        self._thread.join()

    def destroy(self):
        """
        Destroys the probe.

        This method does nothing.
        """
        self._logger.log(Logger.DEBUG_LEVEL,'/mgen/flows destroy')

    def probe(self):
        """
        Gets the current time of day probe data
        """
        self._logger.log(Logger.DEBUG_LEVEL,'/mgen/flows probe')

        del self._measurement_rx.flows_udp.rows[:]

        del self._measurement_rx.flows_tcp.rows[:]

        del self._measurement_tx.flows_udp.rows[:]

        del self._measurement_tx.flows_tcp.rows[:]

        with self._lock:
            for src in self._rx_udp:
                for flow in self._rx_udp[src]:
                    entry = self._rx_udp[src][flow]
                    row = self._measurement_rx.flows_udp.rows.add()

                    value = row.values.add()
                    value.type = MeasurementTable.Measurement.TYPE_STRING
                    value.sValue = entry.source

                    value = row.values.add()
                    value.type = MeasurementTable.Measurement.TYPE_STRING
                    value.sValue = entry.destination

                    value = row.values.add()
                    value.type = MeasurementTable.Measurement.TYPE_UINTEGER
                    value.uValue = entry.flow

                    value = row.values.add()
                    value.type = MeasurementTable.Measurement.TYPE_UINTEGER
                    value.uValue = entry.packets

                    value = row.values.add()
                    value.type = MeasurementTable.Measurement.TYPE_UINTEGER
                    value.uValue = entry.bytes_accum
                    
                    value = row.values.add()
                    value.type = MeasurementTable.Measurement.TYPE_UINTEGER
                    value.uValue = entry.dup_packets

                    value = row.values.add()
                    value.type = MeasurementTable.Measurement.TYPE_UINTEGER
                    value.uValue = entry.dup_bytes_accum
                    
                    value = row.values.add()
                    value.type = MeasurementTable.Measurement.TYPE_DOUBLE
                    if entry.packets:
                        value.dValue = entry.latency_accum / entry.packets
                    else:
                        value.dValue = 0

            for src in self._rx_tcp:
                for flow in self._rx_tcp[src]:
                    entry = self._rx_tcp[src][flow]
                    row = self._measurement_rx.flows_tcp.rows.add()

                    value = row.values.add()
                    value.type = MeasurementTable.Measurement.TYPE_STRING
                    value.sValue = entry.source

                    value = row.values.add()
                    value.type = MeasurementTable.Measurement.TYPE_STRING
                    value.sValue = entry.destination

                    value = row.values.add()
                    value.type = MeasurementTable.Measurement.TYPE_UINTEGER
                    value.uValue = entry.flow

                    value = row.values.add()
                    value.type = MeasurementTable.Measurement.TYPE_UINTEGER
                    value.uValue = entry.packets

                    value = row.values.add()
                    value.type = MeasurementTable.Measurement.TYPE_UINTEGER
                    value.uValue = entry.bytes_accum
                    
                    value = row.values.add()
                    value.type = MeasurementTable.Measurement.TYPE_UINTEGER
                    value.uValue = entry.dup_packets

                    value = row.values.add()
                    value.type = MeasurementTable.Measurement.TYPE_UINTEGER
                    value.uValue = entry.dup_bytes_accum

                    value = row.values.add()
                    value.type = MeasurementTable.Measurement.TYPE_DOUBLE
                    if entry.packets:
                        value.dValue = entry.latency_accum / entry.packets
                    else:
                        value.dValue = 0

            for src_port in self._tx_udp:
                for flow in self._tx_udp[src_port]:
                    entry = self._tx_udp[src_port][flow]
                    row = self._measurement_tx.flows_udp.rows.add()

                    value = row.values.add()
                    value.type = MeasurementTable.Measurement.TYPE_UINTEGER
                    value.uValue = entry.source_port

                    value = row.values.add()
                    value.type = MeasurementTable.Measurement.TYPE_STRING
                    value.sValue = entry.destination

                    value = row.values.add()
                    value.type = MeasurementTable.Measurement.TYPE_UINTEGER
                    value.uValue = entry.flow

                    value = row.values.add()
                    value.type = MeasurementTable.Measurement.TYPE_UINTEGER
                    value.uValue = entry.packets

                    value = row.values.add()
                    value.type = MeasurementTable.Measurement.TYPE_UINTEGER
                    value.uValue = entry.bytes_accum

            for src_port in self._tx_tcp:
                for flow in self._tx_tcp[src_port]:
                    entry = self._tx_tcp[src_port][flow]
                    row = self._measurement_tx.flows_tcp.rows.add()

                    value = row.values.add()
                    value.type = MeasurementTable.Measurement.TYPE_UINTEGER
                    value.uValue = entry.source_port

                    value = row.values.add()
                    value.type = MeasurementTable.Measurement.TYPE_STRING
                    value.sValue = entry.destination

                    value = row.values.add()
                    value.type = MeasurementTable.Measurement.TYPE_UINTEGER
                    value.uValue = entry.flow

                    value = row.values.add()
                    value.type = MeasurementTable.Measurement.TYPE_UINTEGER
                    value.uValue = entry.packets

                    value = row.values.add()
                    value.type = MeasurementTable.Measurement.TYPE_UINTEGER
                    value.uValue = entry.bytes_accum

                    
            # reset
            self._rx_udp = {}
            self._tx_udp = {}
            self._rx_tcp = {}
            self._tx_tcp = {}

            # drop oldest seq history set
            self._seq_history.append(set())
            
        return (("MGEN.Flows.Receive",
                 self._measurement_rx.SerializeToString(),
                 self._measurement_rx.description.name,
                 self._measurement_rx.description.module,
                 self._measurement_rx.description.version),
                ("MGEN.Flows.Transmit",
                 self._measurement_tx.SerializeToString(),
                 self._measurement_tx.description.name,
                 self._measurement_tx.description.module,
                 self._measurement_tx.description.version),)


    def process(self):
        while not self._shutdown_event.is_set():
            try:
                self._ifile = open(self._mgen_output_file,"rt")

                # advance to the end of the file
                self._ifile.seek(0,os.SEEK_END)

                break
            except FileNotFoundError:
                self._logger.log(Logger.ERROR_LEVEL,'/mgen/flows process: missing {}'.format(self._mgen_output_file))
                time.sleep(1)
        
        log_regex = re.compile(r'(\d+:\d+:){0,1}(\d+.\d+) (SEND|RECV|LISTEN|START|STOP)( proto>(UDP|TCP) (flow>(\d+) seq>(\d+) ((src|srcPort)>([^\s]+) dst>([^\s]+))( sent>(\d+:\d+:){0,1}(\d+.\d+)){0,1} size>(\d+)|port>(\d+))){0,1}')

        # consume lines of the file until stop
        while not self._shutdown_event.is_set():
            # read last line of file
            line = self._ifile.readline()
            if not line:
                time.sleep(0.1)
                continue

            match = log_regex.match(line)
            if match:
                log_timestamp = float(match.group(2))

                if match.group(1):
                    hour,minute = [int(x) for x in match.group(1).split(':') if x]
                    log_timestamp += hour * 3600 + minute * 60

                log_type = match.group(3)
                proto = match.group(5)
                
                if log_type == 'RECV':
                    tx_timestamp = float(match.group(15))

                    if match.group(14):
                        hour,minute = [int(x) for x in match.group(14).split(':') if x]
                        tx_timestamp += hour * 3600 + minute * 60

                    flow = int(match.group(7))
                    sequence = int(match.group(8))
                    size = int(match.group(16))
                    src = match.group(11).split('/')[0]
                    dst = match.group(12).split('/')[0]

                    with self._lock:
                        if proto == 'UDP':
                            store = self._rx_udp
                        else:
                            store = self._rx_tcp
                            
                        if src not in store:
                            store[src] = {flow : ReceiveFlow(src,flow,dst)}
                        else:
                            if flow not in store[src]:
                                store[src][flow] = ReceiveFlow(src,flow,dst)

                        dup_found = False
                        for s in self._seq_history:
                            if (src,flow,sequence) in s:
                                dup_found = True
                                break
                        
                        if dup_found:
                            store[src][flow].dup_packets += 1
                            store[src][flow].dup_bytes_accum += size
                        else:
                            store[src][flow].packets += 1
                            store[src][flow].bytes_accum += size
                            store[src][flow].latency_accum += log_timestamp - tx_timestamp
                            self._seq_history[-1].add((src,flow,sequence))

                        
                elif log_type == 'SEND':
                    flow = int(match.group(7))
                    sequence = int(match.group(8))
                    size = int(match.group(16))

                    src_port = int(match.group(11))
                    dst = match.group(12).split('/')[0]

                    with self._lock:
                        if proto == 'UDP':
                            store = self._tx_udp
                        else:
                            store = self._tx_tcp
                            
                        if src_port not in store:
                            store[src_port] = {flow : TransmitFlow(src_port,flow,dst)}
                        else:
                            if flow not in store[src_port]:
                                store[src_port][flow] = TransmitFlow(src_port,flow,dst)

                        store[src_port][flow].packets += 1
                        store[src_port][flow].bytes_accum += size


    
def default_method_format(self,measurement):
    """
    Generates formatted measurement string.
    """
    def fromMeasurement(measurement):
        if measurement.type == MeasurementTable.Measurement.TYPE_SINTEGER:
            return measurement.iValue
        elif measurement.type == MeasurementTable.Measurement.TYPE_UINTEGER:
            return measurement.uValue
        elif measurement.type == MeasurementTable.Measurement.TYPE_DOUBLE:
            return measurement.dValue
        else:
            return measurement.sValue

    def build_table(name,table):
        buf = "[] %s\n" % name

        widths = [];

        for label in table.labels:
            widths.append(len(label))

        for row in table.rows:
            i = 0
            for value in row.values:
                widths[i] = max(widths[i],len(str(fromMeasurement(value))))
                i+=1

        i = 0
        for label in table.labels:
            buf += '|' + label.ljust(widths[i])
            i += 1
        buf += "|\n"

        for row in table.rows:
            i = 0
            for value in row.values:
                val = str(fromMeasurement(value))
                buf += '|' + val.ljust(widths[i])
                i += 1
            buf += "|\n"

        buf += "--\n"

        return buf

    buf= ""
    buf += build_table('flows_udp',measurement.flows_udp)
    buf += build_table('flows_tcp',measurement.flows_tcp)
    return buf
