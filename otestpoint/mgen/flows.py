#
# Copyright (c) 2022-2023 - Adjacent Link LLC, Bridgewater, New Jersey
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in
#    the documentation and/or other materials provided with the
#    distribution.
#  * Neither the name of Adjacent Link LLC nor the names of its
#    contributors may be used to endorse or promote products derived
#    from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#
# See toplevel COPYING for more information.
#

"""
IP Route probe
"""
from otestpoint.interface import Probe
from otestpoint.interface import ProbeException
from otestpoint.interface.measurementtable_pb2 import MeasurementTable
import otestpoint.toolkit.logger as Logger
from .mgen_pb2 import Measurement_mgen_flows_receive
from .mgen_pb2 import Measurement_mgen_flows_transmit

import socket
import json
import struct
import traceback
from lxml import etree

class Flows(Probe):
    schema="""\
<xs:schema xmlns:xs='http://www.w3.org/2001/XMLSchema'>
  <xs:element name='otestpoint-probe-mgen'>
    <xs:complexType>
      <xs:attribute name='monitor-address' type='xs:string' use='required'/>
      <xs:attribute name='monitor-port' type='xs:unsignedShort' use='required'/>
    </xs:complexType>
  </xs:element>
</xs:schema>"""

    def initialize(self,configurationFile=None):
        """
        Initialize the probe.

        Returns:
        The probe name list.
        """
        self._logger.log(Logger.DEBUG_LEVEL,
                         "/mgen/flows/initialize"
                         " configuration: {}".format(configurationFile))

        tree = etree.parse(configurationFile)

        root = tree.getroot()

        schemaDoc = etree.fromstring(Flows.schema)

        schema = etree.XMLSchema(etree=schemaDoc,attribute_defaults=True)

        if not schema(root):
            message = ""
            for entry in schema.error_log:
                message += "%d: %s " % (entry.line,entry.message)
            self._logger.log(Logger.ERROR_LEVEL,"/mgen/flows/initialize %s" % message)
            raise ProbeException(message)

        self._monitor_address = root.get('monitor-address')
        self._monitor_port = int(root.get('monitor-port'))

        self._logger.log(Logger.INFO_LEVEL,
                         "/mgen/flows/initialize config monitor-address: %s " %
                         self._monitor_address)

        self._logger.log(Logger.INFO_LEVEL,
                         "/mgen/flows/initialize config monitor-port: %d " %
                         self._monitor_port)

        receive_labels = ['Src',
                          'Dst',
                          'Flow',
                          'Pkts',
                          'Bytes',
                          'Dup Pkts',
                          'Dup Bytes',
                          'Avg Latency',
                          'Min Seq',
                          'Max Seq']

        transmit_labels = ['Src Port',
                           'Dst',
                           'Flow',
                           'Pkts',
                           'Bytes',
                           'Min Seq',
                           'Max Seq']

        self._measurement_rx = Measurement_mgen_flows_receive()

        self._measurement_rx.flows_udp.labels.extend(receive_labels)

        self._measurement_rx.flows_tcp.labels.extend(receive_labels)

        self._measurement_tx = Measurement_mgen_flows_transmit()

        self._measurement_tx.flows_udp.labels.extend(transmit_labels)

        self._measurement_tx.flows_tcp.labels.extend(transmit_labels)

        return ('MGEN.Flows.Receive',
                'MGEN.Flows.Transmit')

    def start(self):
        """
        Starts the probe.

        This method does nothing.
        """
        self._logger.log(Logger.DEBUG_LEVEL,'/mgen/flows start')


        self._connected = False

    def stop(self):
        """
        Stops the probe.

        This method does nothing.
        """
        self._logger.log(Logger.DEBUG_LEVEL,'/mgen/flows stop')

        self._sock.close()

    def destroy(self):
        """
        Destroys the probe.

        This method does nothing.
        """
        self._logger.log(Logger.DEBUG_LEVEL,'/mgen/flows destroy')

    def probe(self):
        """
        Gets the current time of day probe data
        """
        self._logger.log(Logger.DEBUG_LEVEL,'/mgen/flows probe')

        del self._measurement_rx.flows_udp.rows[:]

        del self._measurement_rx.flows_tcp.rows[:]

        del self._measurement_tx.flows_udp.rows[:]

        del self._measurement_tx.flows_tcp.rows[:]

        if not self._connected:
            try:
                self._sock = socket.socket()
                self._sock.connect((self._monitor_address,self._monitor_port))
                self._connected = True
                self._logger.log(Logger.INFO_LEVEL,'/mgen/flows probe connnect acquired')
            except:
                self._logger.log(Logger.ERROR_LEVEL,'/mgen/flows probe {}'.format(traceback.format_exc()))


        if self._connected:
            self._logger.log(Logger.DEBUG_LEVEL,'/mgen/flows probe send status')
            try:
                if self._sock.send(b'status\n') != 7:
                    self._connected = False
                    self._sock.close()
                    self._logger.log(Logger.ERROR_LEVEL,'/mgen/flows probe send fail connnection lost')
            except:
                self._connected = False
                self._sock.close()
                self._logger.log(Logger.ERROR_LEVEL,'/mgen/flows probe send fail connnection lost')

            messageLengthBytes = 0

            buf = b''

            while self._connected:
                if not messageLengthBytes:
                    data = self._sock.recv(4-len(buf))

                    if not len(data):
                        self._connected = False
                        self._sock.close()
                        self._logger.log(Logger.ERROR_LEVEL,'/mgen/flows probe receive fail connnection lost')
                        break

                    buf += data

                    if len(buf) == 4:
                        (messageLengthBytes,) = struct.unpack('!L',buf);
                        buf = b''

                else:
                    data = self._sock.recv(messageLengthBytes-len(buf))

                    if not len(data):
                        self._connected = False
                        self._sock.close()
                        self._logger.log(Logger.ERROR_LEVEL,'/mgen/flows probe receive fail connnection lost')
                        break

                    buf += data

                    if len(buf) == messageLengthBytes:
                        status = json.loads(buf.decode())

                    for entry in status['rx_udp']:
                        row = self._measurement_rx.flows_udp.rows.add()

                        value = row.values.add()
                        value.type = MeasurementTable.Measurement.TYPE_STRING
                        value.sValue = entry['source']

                        value = row.values.add()
                        value.type = MeasurementTable.Measurement.TYPE_STRING
                        value.sValue = entry['destination']

                        value = row.values.add()
                        value.type = MeasurementTable.Measurement.TYPE_UINTEGER
                        value.uValue = entry['flow']

                        value = row.values.add()
                        value.type = MeasurementTable.Measurement.TYPE_UINTEGER
                        value.uValue = entry['packets']

                        value = row.values.add()
                        value.type = MeasurementTable.Measurement.TYPE_UINTEGER
                        value.uValue = entry['bytes_accum']

                        value = row.values.add()
                        value.type = MeasurementTable.Measurement.TYPE_UINTEGER
                        value.uValue = entry['dup_packets']

                        value = row.values.add()
                        value.type = MeasurementTable.Measurement.TYPE_UINTEGER
                        value.uValue = entry['dup_bytes_accum']

                        value = row.values.add()
                        value.type = MeasurementTable.Measurement.TYPE_DOUBLE
                        if entry['packets']:
                            value.dValue = entry['latency_accum'] / entry['packets']
                        else:
                            value.dValue = 0

                        value = row.values.add()
                        value.type = MeasurementTable.Measurement.TYPE_SINTEGER
                        value.iValue = entry['min_sequence']

                        value = row.values.add()
                        value.type = MeasurementTable.Measurement.TYPE_SINTEGER
                        value.iValue = entry['max_sequence']

                    for entry in status['rx_tcp']:
                        row = self._measurement_rx.flows_tcp.rows.add()

                        value = row.values.add()
                        value.type = MeasurementTable.Measurement.TYPE_STRING
                        value.sValue = entry['source']

                        value = row.values.add()
                        value.type = MeasurementTable.Measurement.TYPE_STRING
                        value.sValue = entry['destination']

                        value = row.values.add()
                        value.type = MeasurementTable.Measurement.TYPE_UINTEGER
                        value.uValue = entry['flow']

                        value = row.values.add()
                        value.type = MeasurementTable.Measurement.TYPE_UINTEGER
                        value.uValue = entry['packets']

                        value = row.values.add()
                        value.type = MeasurementTable.Measurement.TYPE_UINTEGER
                        value.uValue = entry['bytes_accum']

                        value = row.values.add()
                        value.type = MeasurementTable.Measurement.TYPE_UINTEGER
                        value.uValue = entry['dup_packets']

                        value = row.values.add()
                        value.type = MeasurementTable.Measurement.TYPE_UINTEGER
                        value.uValue = entry['dup_bytes_accum']

                        value = row.values.add()
                        value.type = MeasurementTable.Measurement.TYPE_DOUBLE
                        if entry['packets']:
                            value.dValue = entry['latency_accum'] / entry['packets']
                        else:
                            value.dValue = 0

                        value = row.values.add()
                        value.type = MeasurementTable.Measurement.TYPE_SINTEGER
                        value.iValue = entry['min_sequence']

                        value = row.values.add()
                        value.type = MeasurementTable.Measurement.TYPE_SINTEGER
                        value.iValue = entry['max_sequence']

                    for entry in status['tx_udp']:
                        row = self._measurement_tx.flows_udp.rows.add()

                        value = row.values.add()
                        value.type = MeasurementTable.Measurement.TYPE_UINTEGER
                        value.uValue = entry['source_port']

                        value = row.values.add()
                        value.type = MeasurementTable.Measurement.TYPE_STRING
                        value.sValue = entry['destination']

                        value = row.values.add()
                        value.type = MeasurementTable.Measurement.TYPE_UINTEGER
                        value.uValue = entry['flow']

                        value = row.values.add()
                        value.type = MeasurementTable.Measurement.TYPE_UINTEGER
                        value.uValue = entry['packets']

                        value = row.values.add()
                        value.type = MeasurementTable.Measurement.TYPE_UINTEGER
                        value.uValue = entry['bytes_accum']

                        value = row.values.add()
                        value.type = MeasurementTable.Measurement.TYPE_SINTEGER
                        value.iValue = entry['min_sequence']

                        value = row.values.add()
                        value.type = MeasurementTable.Measurement.TYPE_SINTEGER
                        value.iValue = entry['max_sequence']

                    for entry in status['tx_tcp']:
                        row = self._measurement_tx.flows_tcp.rows.add()

                        value = row.values.add()
                        value.type = MeasurementTable.Measurement.TYPE_UINTEGER
                        value.uValue = entry['source_port']

                        value = row.values.add()
                        value.type = MeasurementTable.Measurement.TYPE_STRING
                        value.sValue = entry['destination']

                        value = row.values.add()
                        value.type = MeasurementTable.Measurement.TYPE_UINTEGER
                        value.uValue = entry['flow']

                        value = row.values.add()
                        value.type = MeasurementTable.Measurement.TYPE_UINTEGER
                        value.uValue = entry['packets']

                        value = row.values.add()
                        value.type = MeasurementTable.Measurement.TYPE_UINTEGER
                        value.uValue = entry['bytes_accum']

                        value = row.values.add()
                        value.type = MeasurementTable.Measurement.TYPE_SINTEGER
                        value.iValue = entry['min_sequence']

                        value = row.values.add()
                        value.type = MeasurementTable.Measurement.TYPE_SINTEGER
                        value.iValue = entry['max_sequence']

                    messageLengthBytes = 0
                    buf = b''
                    break

        return (("MGEN.Flows.Receive",
                 self._measurement_rx.SerializeToString(),
                 self._measurement_rx.description.name,
                 self._measurement_rx.description.module,
                 self._measurement_rx.description.version),
                ("MGEN.Flows.Transmit",
                 self._measurement_tx.SerializeToString(),
                 self._measurement_tx.description.name,
                 self._measurement_tx.description.module,
                 self._measurement_tx.description.version),)


def default_method_format(self,measurement):
    """
    Generates formatted measurement string.
    """
    def fromMeasurement(measurement):
        if measurement.type == MeasurementTable.Measurement.TYPE_SINTEGER:
            return measurement.iValue
        elif measurement.type == MeasurementTable.Measurement.TYPE_UINTEGER:
            return measurement.uValue
        elif measurement.type == MeasurementTable.Measurement.TYPE_DOUBLE:
            return measurement.dValue
        else:
            return measurement.sValue

    def build_table(name,table):
        buf = "[] %s\n" % name

        widths = [];

        for label in table.labels:
            widths.append(len(label))

        for row in table.rows:
            i = 0
            for value in row.values:
                widths[i] = max(widths[i],len(str(fromMeasurement(value))))
                i+=1

        i = 0
        for label in table.labels:
            buf += '|' + label.ljust(widths[i])
            i += 1
        buf += "|\n"

        for row in table.rows:
            i = 0
            for value in row.values:
                val = str(fromMeasurement(value))
                buf += '|' + val.ljust(widths[i])
                i += 1
            buf += "|\n"

        buf += "--\n"

        return buf

    buf= ""
    buf += build_table('flows_udp',measurement.flows_udp)
    buf += build_table('flows_tcp',measurement.flows_tcp)
    return buf
